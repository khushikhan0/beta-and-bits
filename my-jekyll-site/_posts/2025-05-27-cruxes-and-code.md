---
layout: post
title:  "Cruxes and Code"
date:   2025-05-27 20:59:41 -0400
categories: jekyll update
---

The clock on my screen read 4:30AM as I stared at the same block of code I had written and deleted for the tenth time. My eyes burned with fatigue, and I found myself questioning my decision to pursue computer science as a major. In the battle of perseverance, exhaustion was beginning to win.  

In moments like these, I find myself wondering: why do people go back to things that are hard? Tasks that often leave us feeling frustrated and humbled? Quitting is the easiest solution. So what drives us to keep going despite it all?    

To dive deeper into this topic, I'd like to begin by delving into a different subject matter for a bit. The relevance might not be obvious at first, but please bear with me. 

In rock climbing, the "crux" can be defined as "the toughest move or sequence of moves on a climb" [(Rei Rock Climbing Glossary)](https://www.rei.com/learn/expert-advice/rock-climbing-glossary.html#:~:text=Crag%E2%80%94A%20small%20cliff%2C%20or,of%20moves%20on%20a%20climb.). Depending on how the crux is structured, the grading and the route can be drastically altered, forming entirely different experiences for the climber. Despite how intimidating this point may sound, it is essential when trying to grow as a climber. The crux teaches you to maneuver your body in ways that may feel unfamiliar, to problem solve on the spot, and to persevere despite the pain and fear involved in enduring. I have been being stuck at a particularly challenging point in a route more times than I can count. The feeling of prickling in your hands, your heart pounding in your chest, the adrenaline that rushes through your veins when you glance down is something I know quite well.    

![Source](image.png)

In many ways, tackling a difficult bug when programming mirrors the experience of working through a crux. The uncertainty and frustration parallel each other, but so does the breakthrough once something finally clicks. Just like how climbers have to re-evaluate their grip or foot placement, programmers have to reframe the problem in front of them over and over again, whether that's through rewriting their logic, testing out edge cases, or debugging line by line.    

Every gnarly bug I've faced, every algorithm that left my brain feeling scrambled, has been a kind of crux. These moments push you past your limits while simultaneously forcing you to keep trying, even when nothing makes sense. They sharpen your mind by encouraging you to think even when you feel like you've hit a dead end. Most importantly of all, these moments are where real growth happens. Your thinking process slowly rewires, your ability to stay steadfast despite challenges grows stronger, and your trust in your ability to problem solve grows more concrete. 

Climbing and programming both share the trait of teaching you problem solving. The simplest method of figuring out a route or a coding challenge is to try doing the entire task over and over again, without putting much thought into how you're viewing the problem. In programming, we call this the brute force solution; the brute force solution is a clunky, slow solution that works but isn't the most efficient in time complexity and/or memory management.    

As you can imagine, doing an entire task over and over again is one of the least efficient ways of approaching problem solving. We may have a solution in the end, but the time it takes to get there will be much longer than some other approaches. Programming and climbing are both tasks that encourage strategy over strength in most cases. One more effective method would be problem decomposition. Problem decomposition can be generally defined as separating a large problem into more doable subproblems. When climbing, this shows up as climbing a specific part of a route over and over again instead of climbing the entire route over and over again. In programming, this can be testing out different edge cases, trying to see the problem at a different angle, or reviewing past approaches to the problem you're facing and attempting to draw connections. When you break up climbing and programming into smaller chunks, it helps you focus in on a few details at a time rather than overwhelming yourself with the entire challenge. Good body positioning is the key to solving a difficult route. Subtleties like your grip and foot positioning can alter the outcome of climbing a route exponentially. When I climb and have trouble figuring out a route, I like to break up the route into different sections. I'll practice the first few feet of the route a handful of times, getting comfortable with the positioning required to accomplish it. Next, I'll move on to the section above the beginning. I may climb up to the start of this section using any kind of hold, just to save my energy for the main route. Once I feel comfortable with subsections of the route, I'lll chunk sections together and climb them until I comfortably complete the entire route. This type of solution is applicable to programming as well. Sometimes you'll find yourself extremely stuck on a problem until you decide to rework your approach. Reworking your approach can be anything from diagramming your code, thinking out loud by explaining what you're trying to accomplish to someone else, or breaking up the problem into different general cases to see how they work together.    

Both climbing and programming are deeply humbling pursuits. They expose our weaknesses, test our patience, and often force us to confront our own limits. But it's precisely in these moments of discomfort—when the solution isn’t obvious, when the next move feels just out of reach—that something more meaningful begins to take shape. When you're suspended mid-route, arms shaking, unsure of your next step, or staring down a wall of code at 4:30AM, wondering if any of it makes sense, the temptation to walk away can be strong. And yet, we return. Again and again.    

I think that’s because somewhere in the process, we begin to recognize that progress rarely looks like a straight path forward. It's found in the subtle shifts—in how we approach a problem, in how we manage frustration, in how we choose to keep trying even when we’ve failed ten times before. Whether it’s adjusting your foot placement on a wall or restructuring a function in your code, each small iteration moves you forward. And eventually, the once impossible task becomes second nature.    

The crux, then, becomes more than just the hardest part of a climb—it becomes a metaphor for the kinds of challenges that shape us. We may not always conquer them on the first try, but the act of showing up, of choosing to engage rather than retreat, is where the real growth lies. In that way, both climbing and programming teach us not just how to solve problems, but how to approach life: one hard move at a time.